#!/usr/bin/env python
import argparse, sys, numpy, itertools
###########################################################
def getParser():
	parser = argparse.ArgumentParser(description='Compute the number of enriched regions between two files.')
	parser.add_argument('-conf',type=str,dest="conf",help="TXT file. Configuration file.")
	parser.add_argument('-control',type=str,dest="control",help="BED file. Control counts.")
	parser.add_argument('-prefix',type=str,dest="prefix",help="STR. Prefix of output file.")
	
	if len(sys.argv) == 1:
		print >> sys.stderr,parser.print_help()
		exit(0)
	return parser
##########################################################
def getUpper( upperFile ):
	upper = {}
	for row,line in enumerate(open(upperFile,"r")):
		if row==0: continue #skip header
		n,mu,upper_value = line.strip().split("\t")[0:3]
		upper[int(n)] = int(upper_value)
	return upper
#################################################################
def getNetProb(casesMatrix,case,probs):
	nCols=probs.shape[1]
	rows=( numpy.sum(casesMatrix*case==case,axis=1 )==nCols )	
	subMatrix = casesMatrix[rows,:]
	
	signs = pow(-1,numpy.sum( subMatrix, axis=1)%2)
	net_probs = []
	for i in range(subMatrix.shape[0]):
		row=subMatrix[i,:]
		net_prob = numpy.product( (row*probs)[0][row!=0]  )
		net_probs.append( net_prob )
	net_prob = numpy.sum(net_probs*signs)
	return abs(net_prob)
###########################################################
def main():
	args = getParser().parse_args()
	confFile    = args.conf
	controlFile = args.control
	prefix  = args.prefix
	####################################################
	# Excecution
	nCols=0
	for line in open(confFile,"r"): nCols+=1
	
	control_counts, coords = [], []
	for nRows,line in enumerate(open(controlFile,"r")): 
		line = line.strip().split("\t")
		if nRows==0: continue # skip header line
		control_count=int( line[-1] )
		control_counts.append(control_count)
		
		coord = "_".join(map( str,line[0:3] ))
		coords.append(coord)
    
	enrichmentMatrix=numpy.zeros((nRows,nCols))

	names = []
	for col, line in enumerate(open(confFile,"r")):
		line = line.strip().split("\t")
		signalFile = line[0]
		upperFile   = line[1]
		names.append( line[2] )
		
		upper = getUpper(upperFile)
		
		for row,sLine in enumerate(open(signalFile,"r")):
			if row==0: continue # skip header line
			s=sLine.strip().split("\t")[-1]
			if not control_counts[row-1] in upper: continue # skip outlier
			if int(s) >= upper[control_counts[row-1]]:
				enrichmentMatrix[row-1,col]=1

	#################################################3
	# Compute overlaps
	cases = list(itertools.product([0, 1], repeat=nCols))	
	casesMatrix=numpy.zeros( (pow(2,nCols),nCols) )
	for row,case in enumerate(cases):
		tmp =  [x for x in case]
		casesMatrix[row,:] = tmp
	sequence = []
	for i in range(nCols):
		sequence.append( pow(2,i+1) )
	sequence = numpy.array(sequence)
	# Save results to file
	flag_counts={}
	out=open(prefix+".enrichment_flags.bed","w")
	for row in range(nRows):
		flag   = sum( pow( sequence, enrichmentMatrix[row,:] ) )
		if flag in flag_counts:
			flag_counts[ flag ] += 1
		else:
			flag_counts[ flag ] = 1
		output = coords[row].split("_")
		output += [ flag ]
		print >>out, "\t".join(map(str,output))
	out.close()
	# Get probabilities and total counts
	all_counts=[]
	for row in range( pow(2,nCols) ):
		flag   = sum( pow( sequence, casesMatrix[row,:] ) )
		all_counts.append(flag_counts[flag])
	probs = numpy.array( numpy.matrix(all_counts) * casesMatrix )
	total_counts = sum(all_counts)
	probs = probs/ total_counts
	# Save cases explanation an summary
	out=open(prefix+".flags_summary.bed","w")
	names += ["flag","Counts","Random_counts"]
	print >>out, "\t".join(map(str,names))
	for row in range( pow(2,nCols) ):
		case = casesMatrix[row,:]
		flag   = sum( pow( sequence, case ) )
		net_prob = getNetProb(casesMatrix,case,probs)
		random_count = total_counts*net_prob
		output = list(case)
		output += [flag, flag_counts[flag],random_count]
		print >>out, "\t".join(map(str,output))
	out.close()

################################################################
if __name__ == '__main__':
	main()
